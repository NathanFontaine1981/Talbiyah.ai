import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, x-requested-with',
  'Access-Control-Max-Age': '86400',
}

interface BookingRequest {
  teacher_id: string;
  date: string;
  time: string;
  subject: string;
  duration?: number;
  price: number;
  use_free_session?: boolean;
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { 
      status: 200,
      headers: corsHeaders 
    })
  }

  console.log('üí≥ INITIATE BOOKING CHECKOUT START:', {
    method: req.method,
    url: req.url,
    timestamp: new Date().toISOString()
  });

  try {
    // Create client with service role key for database operations
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
    )

    // Create separate client with anon key for user authentication
    const supabaseAuth = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    )

    // Get the current user using the auth client
    const {
      data: { user },
    } = await supabaseAuth.auth.getUser()

    if (!user) {
      console.error('‚ùå Unauthorized checkout attempt');
      return new Response(
        JSON.stringify({ success: false, error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    console.log('üë§ User authenticated:', {
      userId: user.id,
      email: user.email
    });

    // Extract bookings array from request body
    const body = await req.json();
    const { bookings: requestedBookings } = body;

    if (!requestedBookings || !Array.isArray(requestedBookings) || requestedBookings.length === 0) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'No bookings provided'
        }),
        { 
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    console.log('üìã Checkout request:', {
      userId: user.id,
      bookingsCount: requestedBookings?.length || 0,
      bookings: requestedBookings?.map((b: BookingRequest) => ({
        teacher: b.teacher_id,
        date: b.date,
        time: b.time,
        subject: b.subject,
        price: b.price
      }))
    });

    if (!requestedBookings || !Array.isArray(requestedBookings) || requestedBookings.length === 0) {
      console.error('‚ùå Invalid bookings array');
      return new Response(
        JSON.stringify({ success: false, error: 'Missing or invalid bookings array' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Validate all bookings first
    for (const booking of requestedBookings) {
      const { teacher_id, date, time, subject } = booking
      if (!teacher_id || !date || !time || !subject) {
        console.error('‚ùå Invalid booking data:', booking);
        return new Response(
          JSON.stringify({ success: false, error: 'Missing required booking information' }),
          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        )
      }
    }

    const teacherIds = Array.from(new Set(requestedBookings.map((booking: BookingRequest) => booking.teacher_id)))
    const subjectSlugs = Array.from(new Set(requestedBookings.map((booking: BookingRequest) => booking.subject)))

    let subjectsData: any[] = []

    if (subjectSlugs.length > 0) {
      const { data: fetchedSubjects, error: subjectsError } = await supabaseClient
        .from('subjects')
        .select('*')
        .in('slug', subjectSlugs)

      if (subjectsError) {
        throw subjectsError
      }

      subjectsData = fetchedSubjects ?? []
    }

    const subjectMap = new Map<string, any>()
    const subjectIdMap = new Map<string, any>()

    subjectsData.forEach(subject => {
      if (subject?.slug) {
        subjectMap.set(subject.slug, subject)
      }
      if (subject?.id) {
        subjectIdMap.set(subject.id, subject)
      }
    })

    if (subjectMap.size !== subjectSlugs.length) {
      throw new Error('One or more selected subjects are not available for booking')
    }

    let teacherSettings: any[] = []

    if (teacherIds.length > 0 && subjectIdMap.size > 0) {
      const subjectIds = Array.from(subjectIdMap.keys())

      const { data: settingsData, error: settingsError } = await supabaseClient
        .from('teacher_subject_settings')
        .select('id, teacher_id, subject_id, hourly_rate, is_enabled')
        .in('teacher_id', teacherIds)
        .in('subject_id', subjectIds)

      if (settingsError) {
        throw settingsError
      }

      teacherSettings = settingsData ?? []
    }

    const rateMap = new Map<string, any>()

    teacherSettings.forEach(setting => {
      const subject = subjectIdMap.get(setting.subject_id)
      const slugKey = subject?.slug ? `${setting.teacher_id}:${subject.slug}` : null
      const idKey = `${setting.teacher_id}:${setting.subject_id}`

      if (slugKey) {
        rateMap.set(slugKey, setting)
      }

      rateMap.set(idKey, setting)
    })

    let teacherRows: any[] = []

    if (teacherIds.length > 0) {
      const { data: fetchedTeachers, error: teacherError } = await supabaseClient
        .from('teachers')
        .select('id, hourly_rate')
        .in('id', teacherIds)

      if (teacherError) {
        throw teacherError
      }

      teacherRows = fetchedTeachers ?? []
    }

    const teacherRateMap = new Map<string, number>()
    teacherRows.forEach(row => {
      teacherRateMap.set(row.id, row.hourly_rate)
    })

    const sanitizedBookings = requestedBookings.map((booking: BookingRequest, index: number) => {
      const subject = subjectMap.get(booking.subject)
      if (!subject) {
        throw new Error(`Subject ${booking.subject} is not available`)
      }

      const allowedDurations = Array.isArray(subject.allowed_durations) && subject.allowed_durations.length > 0
        ? subject.allowed_durations
        : [30, 60]

      const duration = booking.duration ?? 60
      if (!allowedDurations.includes(duration)) {
        throw new Error(`Duration ${duration} minutes is not permitted for ${subject.name}`)
      }

      const rateSlugKey = `${booking.teacher_id}:${booking.subject}`
      const rateIdKey = `${booking.teacher_id}:${subject.id}`
      const rateSetting = rateMap.get(rateSlugKey) ?? rateMap.get(rateIdKey)

      if (rateSetting && rateSetting.is_enabled === false) {
        throw new Error(`Teacher is not accepting bookings for ${subject.name}`)
      }

      const fallbackHourly = teacherRateMap.get(booking.teacher_id) ?? subject.minimum_rate ?? 1500
      let hourlyRate = rateSetting?.hourly_rate ?? fallbackHourly

      if (!hourlyRate || hourlyRate <= 0) {
        hourlyRate = subject.minimum_rate ?? 1500
      }

      if (subject.minimum_rate && hourlyRate < subject.minimum_rate) {
        hourlyRate = subject.minimum_rate
      }

      const calculatedPrice = Math.max(1, Math.round(hourlyRate * (duration / 60)))

      let platformFee = 0
      if (subject.platform_fee_type === 'percentage') {
        const percentage = Number(subject.platform_fee_percentage ?? 0)
        platformFee = Math.round(calculatedPrice * (percentage / 100))
      } else {
        const baseFee = Number(subject.platform_fee_amount ?? 0)
        platformFee = Math.round(baseFee * (duration / 60))
      }

      if (platformFee > calculatedPrice) {
        platformFee = calculatedPrice
      }

      const teacherPayout = Math.max(calculatedPrice - platformFee, 0)

      const billedPrice = booking.use_free_session ? 0 : calculatedPrice
      const billedPlatformFee = booking.use_free_session ? 0 : platformFee
      const billedTeacherPayout = booking.use_free_session ? 0 : teacherPayout

      return {
        ...booking,
        index,
        duration,
        subject_id: subject.id,
        subject_name: subject.name,
        price: billedPrice,
        calculated_price: calculatedPrice,
        platform_fee_amount: billedPlatformFee,
        teacher_payout_amount: billedTeacherPayout,
        teacher_subject_setting_id: rateSetting?.id ?? null,
        hourly_rate_applied: hourlyRate,
        platform_fee_snapshot: {
          type: subject.platform_fee_type,
          amount: subject.platform_fee_amount,
          percentage: subject.platform_fee_percentage,
        },
      }
    })

    const hasFreeSessionBooking = sanitizedBookings.some((booking: any) => booking.use_free_session === true)
    const freeSessionBookings = sanitizedBookings.filter((booking: any) => booking.use_free_session === true)
    const paidBookings = sanitizedBookings.filter((booking: any) => booking.use_free_session !== true)

    if (hasFreeSessionBooking) {
      if (paidBookings.length === 0) {
        return new Response(
          JSON.stringify({
            success: false,
            error: 'To use your free 30-minute session, you must also book at least one paid session.'
          }),
          {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          }
        );
      }

      const { data: profile } = await supabaseClient
        .from('profiles')
        .select('free_sessions_remaining')
        .eq('id', user.id)
        .single();

      if (!profile || !profile.free_sessions_remaining || profile.free_sessions_remaining <= 0) {
        return new Response(
          JSON.stringify({
            success: false,
            error: 'No free sessions available'
          }),
          {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          }
        );
      }

      if (freeSessionBookings.length > 1) {
        return new Response(
          JSON.stringify({
            success: false,
            error: 'You can only use one free session per booking'
          }),
          {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          }
        );
      }

      console.log('Mixed booking detected:', {
        freeSessionsCount: freeSessionBookings.length,
        paidSessionsCount: paidBookings.length,
        totalSessions: sanitizedBookings.length
      });
    }

    console.log('üîç Checking for booking conflicts...');

    // Check for conflicts with all requested slots
    const conflictChecks = sanitizedBookings.map((booking: any) =>
      supabaseClient
        .from('bookings')
        .select('id')
        .eq('teacher_id', booking.teacher_id)
        .eq('scheduled_date', booking.date)
        .eq('scheduled_time', booking.time)
        .in('status', ['confirmed', 'pending'])
    )

    const conflictResults = await Promise.all(conflictChecks)

    // Check if any slots are already booked
    for (let i = 0; i < conflictResults.length; i++) {
      const { data: existingBookings } = conflictResults[i]
      if (existingBookings && existingBookings.length > 0) {
        const conflictBooking = sanitizedBookings[i]
        console.error('‚ö†Ô∏è Booking conflict detected:', {
          conflictIndex: i,
          booking: conflictBooking,
          existingBookings
        });
        
        return new Response(
          JSON.stringify({ 
            success: false, 
            error: `Time slot on ${conflictBooking.date} at ${conflictBooking.time} is no longer available`,
            conflictIndex: i
          }),
          { status: 409, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        )
      }
    }

    console.log('‚úÖ No conflicts detected');

    // Calculate total amount (excluding free sessions)
    const totalAmount = sanitizedBookings.reduce((sum: number, booking: any) => {
      return sum + (booking.price || 0)
    }, 0)

    const totalCalculatedAmount = sanitizedBookings.reduce((sum: number, booking: any) => {
      return sum + (booking.calculated_price || 0)
    }, 0)

    const totalPlatformFee = sanitizedBookings.reduce((sum: number, booking: any) => {
      return sum + (booking.platform_fee_amount || 0)
    }, 0)

    const totalTeacherPayout = sanitizedBookings.reduce((sum: number, booking: any) => {
      return sum + (booking.teacher_payout_amount || 0)
    }, 0)

    const totalDiscountAmount = Math.max(totalCalculatedAmount - totalAmount, 0)

    const pricingSnapshot = {
      currency: 'gbp',
      has_free_session: hasFreeSessionBooking,
      total_amount: totalAmount,
      total_calculated_amount: totalCalculatedAmount,
      total_platform_fee: totalPlatformFee,
      total_teacher_payout: totalTeacherPayout,
      total_discount_amount: totalDiscountAmount,
      bookings: sanitizedBookings.map((booking: any) => ({
        index: booking.index,
        teacher_id: booking.teacher_id,
        subject: booking.subject,
        subject_id: booking.subject_id,
        subject_name: booking.subject_name,
        date: booking.date,
        time: booking.time,
        duration: booking.duration,
        calculated_price: booking.calculated_price,
        billed_price: booking.price,
        platform_fee_amount: booking.platform_fee_amount,
        teacher_payout_amount: booking.teacher_payout_amount,
        hourly_rate_applied: booking.hourly_rate_applied,
        use_free_session: booking.use_free_session === true,
        platform_fee_snapshot: booking.platform_fee_snapshot,
        teacher_subject_setting_id: booking.teacher_subject_setting_id,
      }))
    }

    console.log('üí∞ Checkout total:', {
      sessionCount: sanitizedBookings.length,
      totalAmount,
      totalCalculatedAmount,
      totalPlatformFee,
      totalTeacherPayout,
      totalGBP: (totalAmount / 100).toFixed(2)
    });

    // Create pending booking record
    console.log('üìù Creating pending booking...');
    
    const { data: pendingBooking, error: pendingError } = await supabaseClient
      .from('pending_bookings')
      .insert([{
        user_id: user.id,
        bookings_data: sanitizedBookings,
        total_amount: totalAmount,
        status: 'pending',
        pricing_snapshot: pricingSnapshot
      }])
      .select('id')
      .single()

    if (pendingError) {
      console.error('‚ùå Error creating pending booking:', pendingError);
      throw new Error(`Failed to create pending booking: ${pendingError.message}`)
    }

    console.log('‚úÖ Pending booking created:', {
      pendingBookingId: pendingBooking.id
    });

    // Get Stripe configuration
    const stripeKey = Deno.env.get('STRIPE_SECRET_KEY')
    if (!stripeKey) {
      console.error('‚ùå Stripe secret key not found');
      throw new Error('Stripe secret key not found')
    }

    // Create Stripe Checkout Session
    const sessionCount = sanitizedBookings.length
    const paidSessionCount = paidBookings.length
    const sessionText = sessionCount === 1 ? 'Session' : 'Sessions'
    const subjectNames = Array.from(new Set(sanitizedBookings.map((booking: any) => {
      if (booking.subject_name) {
        return booking.subject_name
      }
      if (typeof booking.subject === 'string') {
        return booking.subject
          .replace(/-/g, ' ')
          .replace(/\b\w/g, (letter: string) => letter.toUpperCase())
      }
      return 'Tutoring'
    })))
    const subjectLabel = subjectNames.length === 1
      ? (subjectNames[0] || 'Tutoring')
      : 'Multiple Subjects'
    const subjectSlugs = Array.from(new Set(sanitizedBookings.map((booking: any) => booking.subject)))
    const primarySubjectSlug = subjectSlugs.length === 1
      ? (subjectSlugs[0] || 'general')
      : 'multiple-subjects'

    // Generate accurate session description for mixed durations
    const sessionsByDuration = sanitizedBookings.reduce((acc: Record<number, number>, booking: any) => {
      const duration = booking.duration || 60; // Default to 60 if not specified
      acc[duration] = (acc[duration] || 0) + 1;
      return acc;
    }, {} as Record<number, number>);
    
    // Build description string based on actual durations
    let sessionDescription = '';
    const durations = Object.keys(sessionsByDuration).map(Number).sort();
    
    if (durations.length === 1) {
      // All sessions have the same duration
      const duration = durations[0];
      const count = sessionsByDuration[duration];
      sessionDescription = `${count} x ${duration}-minute session${count > 1 ? 's' : ''}`;
    } else {
      // Mixed durations
      const parts = durations.map(duration => {
        const count = sessionsByDuration[duration];
        return `${count} x ${duration}-min`;
      });
      sessionDescription = parts.join(' + ');
    }
    
    // Add free session note if applicable
    if (hasFreeSessionBooking) {
      sessionDescription += ' (includes 1 FREE 30-min trial session)';
    }

    const baseProductName = `${sessionCount} ${subjectLabel} ${sessionText}`.trim()
    const productName = hasFreeSessionBooking
      ? `${baseProductName} (${paidSessionCount} paid + 1 free)`
      : baseProductName

    console.log('üõí Creating Stripe checkout session...');

    const checkoutData = new URLSearchParams({
      'payment_method_types[]': 'card',
      'line_items[0][price_data][currency]': 'gbp',
      'line_items[0][price_data][unit_amount]': totalAmount.toString(),
      'line_items[0][price_data][product_data][name]': productName,
      'line_items[0][price_data][product_data][description]': `${sessionDescription} - ${subjectLabel}`,
      'line_items[0][quantity]': '1',
      mode: 'payment',
      allow_promotion_codes: 'true', // ‚Üê ADD THIS LINE for coupon codes
      success_url: `${req.headers.get('origin') || 'https://azhariacademy.co.uk'}/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${req.headers.get('origin') || 'https://azhariacademy.co.uk'}/booking`,
      'metadata[pending_booking_id]': pendingBooking.id,
      'metadata[user_id]': user.id,
      'metadata[session_count]': sessionCount.toString(),
      'metadata[subject]': primarySubjectSlug,
      'metadata[total_amount]': totalAmount.toString(),
      'metadata[total_platform_fee]': totalPlatformFee.toString(),
      'metadata[total_teacher_payout]': totalTeacherPayout.toString(),
      'metadata[total_calculated_amount]': totalCalculatedAmount.toString(),
      'metadata[has_free_session]': hasFreeSessionBooking ? 'true' : 'false',
      'metadata[pricing_version]': '2',
      'customer_email': user.email || ''
    })

    console.log('üìã Stripe checkout data:', {
      currency: 'gbp',
      amount: totalAmount,
      productName,
      sessionDescription,
      subjectLabel,
      successUrl: `${req.headers.get('origin') || 'https://azhariacademy.co.uk'}/success?session_id={CHECKOUT_SESSION_ID}`,
      pendingBookingId: pendingBooking.id,
      userEmail: user.email
    });

    const checkoutResponse = await fetch('https://api.stripe.com/v1/checkout/sessions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${stripeKey}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: checkoutData
    })

    if (!checkoutResponse.ok) {
      const error = await checkoutResponse.text()
      console.error('‚ùå Stripe checkout session creation failed:', {
        status: checkoutResponse.status,
        error
      });
      throw new Error(`Failed to create checkout session: ${error}`)
    }

    const session = await checkoutResponse.json()

    console.log('‚úÖ Stripe checkout session created:', {
      sessionId: session.id,
      url: session.url,
      mode: session.mode,
      paymentStatus: session.payment_status
    });

    // Update pending booking with Stripe session ID
    console.log('üîó Linking pending booking to Stripe session...');
    
    const { error: linkError } = await supabaseClient
      .from('pending_bookings')
      .update({ stripe_session_id: session.id })
      .eq('id', pendingBooking.id)

    if (linkError) {
      console.error('‚ö†Ô∏è Failed to link pending booking to Stripe session:', linkError);
    } else {
      console.log('‚úÖ Pending booking linked to Stripe session');
    }

    const result = {
      success: true,
      checkout_url: session.url,
      session_id: session.id,
      pending_booking_id: pendingBooking.id,
      total_amount: totalAmount,
      session_count: sessionCount,
      bookings: sanitizedBookings,
      pricing_snapshot: pricingSnapshot,
      has_free_session: hasFreeSessionBooking,
      total_platform_fee: totalPlatformFee,
      total_teacher_payout: totalTeacherPayout,
      total_calculated_amount: totalCalculatedAmount,
      total_discount_amount: totalDiscountAmount
    };

    console.log('üéâ CHECKOUT INITIATION COMPLETE:', {
      success: true,
      sessionId: session.id,
      pendingBookingId: pendingBooking.id,
      totalAmount,
      checkoutUrl: session.url,
      sessionCount,
      totalPlatformFee,
      totalTeacherPayout
    });

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('üí• CHECKOUT INITIATION ERROR:', {
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
    
    return new Response(
      JSON.stringify({ success: false, error: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})